"use strict";(globalThis.webpackChunkphysical_ai_handbook=globalThis.webpackChunkphysical_ai_handbook||[]).push([[230],{1495:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Advanced-Topics/sim-to-real-transfer","title":"sim-to-real-transfer","description":"Hero Diagram: Sim-to-Real Transfer","source":"@site/docs/Advanced-Topics/12-sim-to-real-transfer.md","sourceDirName":"Advanced-Topics","slug":"/Advanced-Topics/sim-to-real-transfer","permalink":"/github.com/Anam258/my-handbook/docs/Advanced-Topics/sim-to-real-transfer","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Advanced-Topics/12-sim-to-real-transfer.md","tags":[],"version":"current","sidebarPosition":12,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"vla-cognitive-planning","permalink":"/github.com/Anam258/my-handbook/docs/Module-04-VLA-Voice/vla-cognitive-planning"},"next":{"title":"hardware-lab-setup","permalink":"/github.com/Anam258/my-handbook/docs/Advanced-Topics/hardware-lab-setup"}}');var a=r(4848),s=r(8453);const t={},o="Sim-to-Real Transfer",l={},d=[{value:"Understanding the Reality Gap",id:"understanding-the-reality-gap",level:2},{value:"Key Components of the Reality Gap",id:"key-components-of-the-reality-gap",level:3},{value:"Domain Randomization Techniques",id:"domain-randomization-techniques",level:2},{value:"Visual Domain Randomization",id:"visual-domain-randomization",level:3},{value:"Physical Domain Randomization",id:"physical-domain-randomization",level:3},{value:"System Identification for Model Refinement",id:"system-identification-for-model-refinement",level:2},{value:"Validation and Evaluation Methods",id:"validation-and-evaluation-methods",level:2},{value:"Performance Metrics",id:"performance-metrics",level:3},{value:"Advanced Transfer Techniques",id:"advanced-transfer-techniques",level:2},{value:"Domain Adaptation",id:"domain-adaptation",level:3},{value:"Fine-Tuning Strategies",id:"fine-tuning-strategies",level:3},{value:"Hands-on Lab",id:"hands-on-lab",level:2},{value:"Self-Assessment",id:"self-assessment",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Hero Diagram: Sim-to-Real Transfer",src:r(2124).A+"",width:"1024",height:"1024"})}),"\n",(0,a.jsx)(n.admonition,{title:"Learning Objectives",type:"info",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Understand the challenges and techniques for sim-to-real transfer"}),"\n",(0,a.jsx)(n.li,{children:"Implement domain randomization to improve transferability"}),"\n",(0,a.jsx)(n.li,{children:"Apply system identification methods to bridge the sim-to-real gap"}),"\n",(0,a.jsx)(n.li,{children:"Evaluate and validate robot behaviors across simulation and real platforms"}),"\n"]})}),"\n",(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"sim-to-real-transfer",children:"Sim-to-Real Transfer"})}),"\n",(0,a.jsx)(n.p,{children:'Sim-to-real transfer is the process of developing and training robotic systems in simulation environments and successfully deploying them on physical robots. This approach significantly reduces development time and costs while ensuring safety during algorithm development. However, the "reality gap" between simulation and the real world presents significant challenges.'}),"\n",(0,a.jsx)(n.h2,{id:"understanding-the-reality-gap",children:"Understanding the Reality Gap"}),"\n",(0,a.jsx)(n.p,{children:"The reality gap encompasses differences between simulated and real environments that can cause algorithms trained in simulation to fail when deployed on physical robots:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Visual differences"}),": Lighting, textures, and sensor noise"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Physical differences"}),": Friction, compliance, and dynamics"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Temporal differences"}),": Timing and latency variations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sensor differences"}),": Noise, resolution, and accuracy variations"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"key-components-of-the-reality-gap",children:"Key Components of the Reality Gap"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Simulation parameters\r\nSIMULATION_PARAMS = {\r\n    'gravity': 9.81,  # Perfectly known\r\n    'friction': 0.5,  # Constant value\r\n    'sensor_noise': 0.0,  # Noise-free sensors\r\n    'timing': 0.0  # Perfect timing\r\n}\r\n\r\n# Real-world parameters (variable and uncertain)\r\nREAL_WORLD_PARAMS = {\r\n    'gravity': 9.81 + random.uniform(-0.05, 0.05),\r\n    'friction': [0.3, 0.7],  # Range of possible values\r\n    'sensor_noise': measured_noise_profile,\r\n    'timing': measured_latency_distribution\r\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{title:"Key Concept",type:"tip",children:(0,a.jsx)(n.p,{children:"Domain randomization is a key technique for reducing the sim-to-real gap by training models across a wide range of randomized simulation conditions, making them robust to variations encountered in the real world."})}),"\n",(0,a.jsx)(n.h2,{id:"domain-randomization-techniques",children:"Domain Randomization Techniques"}),"\n",(0,a.jsx)(n.p,{children:"Domain randomization systematically varies simulation parameters to improve transferability:"}),"\n",(0,a.jsx)(n.h3,{id:"visual-domain-randomization",children:"Visual Domain Randomization"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class VisualRandomizer:\r\n    def __init__(self):\r\n        self.lighting_range = (50, 200)  # Light intensity range\r\n        self.texture_set = ['wood', 'metal', 'fabric', 'concrete']\r\n        self.color_range = (0.1, 0.9)    # Color variation\r\n\r\n    def randomize_visuals(self, scene):\r\n        \"\"\"Randomize visual properties in the scene\"\"\"\r\n        # Randomize lighting\r\n        light_intensity = random.uniform(*self.lighting_range)\r\n        scene.set_light_intensity(light_intensity)\r\n\r\n        # Randomize textures\r\n        random_texture = random.choice(self.texture_set)\r\n        scene.apply_texture(random_texture)\r\n\r\n        # Randomize colors\r\n        random_color = [random.uniform(*self.color_range) for _ in range(3)]\r\n        scene.set_object_colors(random_color)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"physical-domain-randomization",children:"Physical Domain Randomization"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class PhysicsRandomizer:\r\n    def __init__(self):\r\n        self.mass_variance = 0.1  # \xb110% mass variation\r\n        self.friction_range = (0.3, 0.8)\r\n        self.damping_range = (0.01, 0.1)\r\n\r\n    def randomize_physics(self, robot_model):\r\n        """Randomize physical properties of the robot"""\r\n        # Randomize link masses\r\n        for link in robot_model.links:\r\n            original_mass = link.mass\r\n            randomized_mass = original_mass * random.uniform(\r\n                1 - self.mass_variance,\r\n                1 + self.mass_variance\r\n            )\r\n            link.mass = randomized_mass\r\n\r\n        # Randomize friction coefficients\r\n        for joint in robot_model.joints:\r\n            joint.friction = random.uniform(*self.friction_range)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"system-identification-for-model-refinement",children:"System Identification for Model Refinement"}),"\n",(0,a.jsx)(n.p,{children:"System identification helps bridge the sim-to-real gap by identifying real-world parameters:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import numpy as np\r\nfrom scipy.optimize import minimize\r\n\r\nclass SystemIdentifier:\r\n    def __init__(self, simulation_model):\r\n        self.sim_model = simulation_model\r\n        self.real_data = []\r\n\r\n    def collect_real_data(self, robot, trajectory):\r\n        """Collect real-world data for system identification"""\r\n        states = []\r\n        actions = []\r\n\r\n        for action in trajectory:\r\n            robot.execute_action(action)\r\n            state = robot.get_state()\r\n            states.append(state)\r\n            actions.append(action)\r\n\r\n        return states, actions\r\n\r\n    def identify_parameters(self, real_states, real_actions):\r\n        """Identify simulation parameters that match real behavior"""\r\n        def parameter_error(params):\r\n            # Set simulation parameters\r\n            self.sim_model.set_params(params)\r\n\r\n            # Simulate the same trajectory\r\n            sim_states = self.sim_model.simulate(real_actions)\r\n\r\n            # Calculate error between real and simulated states\r\n            error = np.mean([\r\n                np.linalg.norm(real - sim)\r\n                for real, sim in zip(real_states, sim_states)\r\n            ])\r\n            return error\r\n\r\n        # Optimize parameters to minimize error\r\n        result = minimize(parameter_error,\r\n                         x0=self.sim_model.get_default_params(),\r\n                         method=\'BFGS\')\r\n\r\n        return result.x\n'})}),"\n",(0,a.jsx)(n.h2,{id:"validation-and-evaluation-methods",children:"Validation and Evaluation Methods"}),"\n",(0,a.jsx)(n.p,{children:"Validating sim-to-real transfer requires systematic evaluation:"}),"\n",(0,a.jsx)(n.h3,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class TransferEvaluator:\r\n    def __init__(self):\r\n        self.metrics = {\r\n            'success_rate': 0,\r\n            'task_completion_time': float('inf'),\r\n            'energy_efficiency': 0,\r\n            'safety_violations': 0\r\n        }\r\n\r\n    def evaluate_transfer(self, sim_policy, real_robot):\r\n        \"\"\"Evaluate policy transfer performance\"\"\"\r\n        results = []\r\n\r\n        for task in self.task_set:\r\n            # Execute task in simulation\r\n            sim_result = self.execute_in_simulation(sim_policy, task)\r\n\r\n            # Execute task on real robot\r\n            real_result = self.execute_on_robot(sim_policy, task)\r\n\r\n            # Compare results\r\n            transfer_quality = self.compare_results(sim_result, real_result)\r\n            results.append(transfer_quality)\r\n\r\n        return self.aggregate_results(results)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-transfer-techniques",children:"Advanced Transfer Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"domain-adaptation",children:"Domain Adaptation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Using domain adaptation networks\r\nimport torch\r\nimport torch.nn as nn\r\n\r\nclass DomainAdaptationNet(nn.Module):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.feature_extractor = nn.Sequential(\r\n            nn.Linear(768, 512),  # Vision features\r\n            nn.ReLU(),\r\n            nn.Linear(512, 256),\r\n            nn.ReLU()\r\n        )\r\n\r\n        self.sim_classifier = nn.Linear(256, 2)  # Sim vs Real\r\n        self.task_classifier = nn.Linear(256, 10)  # Task classes\r\n\r\n    def forward(self, x):\r\n        features = self.feature_extractor(x)\r\n        sim_pred = self.sim_classifier(features)\r\n        task_pred = self.task_classifier(features)\r\n        return features, sim_pred, task_pred\n"})}),"\n",(0,a.jsx)(n.h3,{id:"fine-tuning-strategies",children:"Fine-Tuning Strategies"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def fine_tune_for_real(robot, sim_policy, real_episodes=10):\r\n    """Fine-tune simulation-trained policy on real robot"""\r\n    policy = copy.deepcopy(sim_policy)\r\n\r\n    for episode in range(real_episodes):\r\n        # Collect small amount of real data\r\n        real_data = collect_real_experience(robot, policy)\r\n\r\n        # Update policy with real data\r\n        policy.update(real_data)\r\n\r\n        # Evaluate updated policy\r\n        success_rate = evaluate_policy(robot, policy)\r\n\r\n        if success_rate > 0.9:  # Sufficient performance\r\n            break\r\n\r\n    return policy\n'})}),"\n",(0,a.jsx)(n.h2,{id:"hands-on-lab",children:"Hands-on Lab"}),"\n",(0,a.jsx)(n.p,{children:"Implement sim-to-real transfer techniques with:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Domain randomization in simulation"}),"\n",(0,a.jsx)(n.li,{children:"System identification for parameter estimation"}),"\n",(0,a.jsx)(n.li,{children:"Policy evaluation across simulation and real platforms"}),"\n",(0,a.jsx)(n.li,{children:"Fine-tuning strategies for improved transfer"}),"\n",(0,a.jsx)(n.li,{children:"Performance comparison and analysis"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"self-assessment",children:"Self-Assessment"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:'What is the "reality gap" and why does it occur?'}),"\n",(0,a.jsx)(n.li,{children:"How does domain randomization help with sim-to-real transfer?"}),"\n",(0,a.jsx)(n.li,{children:"What are the key challenges in validating sim-to-real transfer?"}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},2124:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/sim-to-real-b35c0e7e8eeac7b6432c41b8b1a0a38c.jpg"},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var i=r(6540);const a={},s=i.createContext(a);function t(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);