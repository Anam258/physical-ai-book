"use strict";(globalThis.webpackChunkphysical_ai_handbook=globalThis.webpackChunkphysical_ai_handbook||[]).push([[182],{2015:(n,e,i)=>{i.d(e,{A:()=>o});const o=i.p+"assets/images/ros2-network-3d946ed883f1cf28598d1c6f59ec1f53.png"},4221:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"Module-01-ROS2/ros2-fundamentals-3","title":"ros2-fundamentals-3","description":"Hero Diagram: URDF for Humanoids","source":"@site/docs/Module-01-ROS2/04-ros2-fundamentals-3.md","sourceDirName":"Module-01-ROS2","slug":"/Module-01-ROS2/ros2-fundamentals-3","permalink":"/physical-ai-book/docs/Module-01-ROS2/ros2-fundamentals-3","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Module-01-ROS2/04-ros2-fundamentals-3.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ros2-fundamentals-2","permalink":"/physical-ai-book/docs/Module-01-ROS2/ros2-fundamentals-2"},"next":{"title":"gazebo-simulation-1","permalink":"/physical-ai-book/docs/Module-02-Simulation/gazebo-simulation-1"}}');var r=i(4848),s=i(8453);const t={},a="ROS 2 Fundamentals 3: URDF for Humanoids",l={},d=[{value:"Understanding URDF Structure",id:"understanding-urdf-structure",level:2},{value:"Basic URDF Components",id:"basic-urdf-components",level:3},{value:"Humanoid-Specific Considerations",id:"humanoid-specific-considerations",level:2},{value:"Multi-Body Structure for Humanoids",id:"multi-body-structure-for-humanoids",level:3},{value:"Validation and Visualization",id:"validation-and-visualization",level:2},{value:"Hands-on Lab",id:"hands-on-lab",level:2},{value:"Self-Assessment",id:"self-assessment",level:2}];function c(n){const e={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{alt:"Hero Diagram: URDF for Humanoids",src:i(2015).A+"",width:"688",height:"1024"})}),"\n",(0,r.jsx)(e.admonition,{title:"Learning Objectives",type:"info",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Understand the Unified Robot Description Format (URDF) for humanoid robots"}),"\n",(0,r.jsx)(e.li,{children:"Create complex robot models with multiple joints and links"}),"\n",(0,r.jsx)(e.li,{children:"Implement kinematic chains for bipedal locomotion"}),"\n",(0,r.jsx)(e.li,{children:"Validate and visualize URDF models in RViz and Gazebo"}),"\n"]})}),"\n",(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"ros-2-fundamentals-3-urdf-for-humanoids",children:"ROS 2 Fundamentals 3: URDF for Humanoids"})}),"\n",(0,r.jsx)(e.p,{children:"The Unified Robot Description Format (URDF) is an XML-based format used to describe robot models in ROS. For humanoid robots, URDF becomes particularly important as it defines the complex kinematic structure with multiple degrees of freedom required for bipedal locomotion and dexterous manipulation."}),"\n",(0,r.jsx)(e.h2,{id:"understanding-urdf-structure",children:"Understanding URDF Structure"}),"\n",(0,r.jsxs)(e.p,{children:["URDF describes robots in terms of ",(0,r.jsx)(e.strong,{children:"links"})," and ",(0,r.jsx)(e.em,{children:"joints"}),". Links represent rigid bodies, while joints define the kinematic and dynamic relationships between links. A humanoid robot typically includes:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Links"}),": Head, torso, arms (upper/lower), hands, legs (upper/lower), feet"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Joints"}),": Revolute (rotational), prismatic (linear), fixed connections"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"basic-urdf-components",children:"Basic URDF Components"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="humanoid_robot">\r\n  \x3c!-- Links define rigid bodies --\x3e\r\n  <link name="base_link">\r\n    <visual>\r\n      <geometry>\r\n        <box size="0.2 0.1 0.1"/>\r\n      </geometry>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <box size="0.2 0.1 0.1"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Joints define connections between links --\x3e\r\n  <joint name="joint_name" type="revolute">\r\n    <parent link="base_link"/>\r\n    <child link="child_link"/>\r\n    <origin xyz="0.1 0 0" rpy="0 0 0"/>\r\n    <axis xyz="0 0 1"/>\r\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\r\n  </joint>\r\n</robot>\n'})}),"\n",(0,r.jsx)(e.admonition,{title:"Key Concept",type:"tip",children:(0,r.jsx)(e.p,{children:"URDF defines the kinematic structure of robots, which is essential for forward and inverse kinematics calculations needed for humanoid locomotion and manipulation tasks."})}),"\n",(0,r.jsx)(e.h2,{id:"humanoid-specific-considerations",children:"Humanoid-Specific Considerations"}),"\n",(0,r.jsx)(e.p,{children:"Humanoid robots require special attention to balance and locomotion. The center of mass must be carefully calculated and maintained within the support polygon during walking. URDF models must include:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Accurate inertial properties for each link"}),"\n",(0,r.jsx)(e.li,{children:"Proper joint limits to prevent self-collision"}),"\n",(0,r.jsx)(e.li,{children:"Correct mass distribution for stable locomotion"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"multi-body-structure-for-humanoids",children:"Multi-Body Structure for Humanoids"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example humanoid torso --\x3e\r\n<link name="torso">\r\n  <visual>\r\n    <geometry>\r\n      <cylinder radius="0.08" length="0.3"/>\r\n    </geometry>\r\n    <material name="gray">\r\n      <color rgba="0.5 0.5 0.5 1.0"/>\r\n    </material>\r\n  </visual>\r\n</link>\r\n\r\n\x3c!-- Hip joint for leg attachment --\x3e\r\n<joint name="left_hip_joint" type="revolute">\r\n  <parent link="torso"/>\r\n  <child link="left_thigh"/>\r\n  <origin xyz="0 -0.1 -0.15" rpy="0 0 0"/>\r\n  <axis xyz="0 0 1"/>\r\n  <limit lower="-1.57" upper="1.57" effort="200" velocity="2"/>\r\n</joint>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"validation-and-visualization",children:"Validation and Visualization"}),"\n",(0,r.jsx)(e.p,{children:"URDF models should be validated for kinematic correctness and visualized before simulation:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Check URDF for errors\r\ncheck_urdf my_humanoid.urdf\r\n\r\n# Visualize in RViz\r\nros2 run rviz2 rviz2\r\n\r\n# Launch in Gazebo\r\nros2 launch gazebo_ros gazebo.launch.py\n"})}),"\n",(0,r.jsx)(e.h2,{id:"hands-on-lab",children:"Hands-on Lab"}),"\n",(0,r.jsx)(e.p,{children:"Create a simplified humanoid model with:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"A torso and head"}),"\n",(0,r.jsx)(e.li,{children:"Two arms with shoulder, elbow, and wrist joints"}),"\n",(0,r.jsx)(e.li,{children:"Two legs with hip, knee, and ankle joints"}),"\n",(0,r.jsx)(e.li,{children:"Proper inertial properties for each link"}),"\n",(0,r.jsx)(e.li,{children:"Visualize your model in RViz"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"self-assessment",children:"Self-Assessment"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"What are the main components of a URDF file?"}),"\n",(0,r.jsx)(e.li,{children:"Why is accurate inertial information important for humanoid robots?"}),"\n",(0,r.jsx)(e.li,{children:"How do joints define the kinematic structure of a robot?"}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>a});var o=i(6540);const r={},s=o.createContext(r);function t(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:t(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);