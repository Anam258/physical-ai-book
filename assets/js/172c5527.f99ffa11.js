"use strict";(globalThis.webpackChunkphysical_ai_handbook=globalThis.webpackChunkphysical_ai_handbook||[]).push([[261],{2015:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/ros2-network-3d946ed883f1cf28598d1c6f59ec1f53.png"},2048:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Module-01-ROS2/ros2-fundamentals-1","title":"ros2-fundamentals-1","description":"Hero Diagram: ROS 2 Nodes, Topics, Services","source":"@site/docs/Module-01-ROS2/02-ros2-fundamentals-1.md","sourceDirName":"Module-01-ROS2","slug":"/Module-01-ROS2/ros2-fundamentals-1","permalink":"/physical-ai-book/docs/Module-01-ROS2/ros2-fundamentals-1","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Module-01-ROS2/02-ros2-fundamentals-1.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"intro-physical-ai","permalink":"/physical-ai-book/docs/Introduction/intro-physical-ai"},"next":{"title":"ros2-fundamentals-2","permalink":"/physical-ai-book/docs/Module-01-ROS2/ros2-fundamentals-2"}}');var r=s(4848),t=s(8453);const o={},a="ROS 2 Fundamentals 1: Nodes, Topics, and Services",c={},l=[{value:"Understanding ROS 2 Nodes",id:"understanding-ros-2-nodes",level:2},{value:"Creating Your First Node",id:"creating-your-first-node",level:3},{value:"Communication Patterns: Topics",id:"communication-patterns-topics",level:2},{value:"Working with Topics",id:"working-with-topics",level:3},{value:"Communication Patterns: Services",id:"communication-patterns-services",level:2},{value:"Implementing Services",id:"implementing-services",level:3},{value:"Hands-on Lab",id:"hands-on-lab",level:2},{value:"Self-Assessment",id:"self-assessment",level:2}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Hero Diagram: ROS 2 Nodes, Topics, Services",src:s(2015).A+"",width:"688",height:"1024"})}),"\n",(0,r.jsx)(n.admonition,{title:"Learning Objectives",type:"info",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understand the core concepts of ROS 2 architecture"}),"\n",(0,r.jsx)(n.li,{children:"Learn how to create and manage ROS 2 nodes"}),"\n",(0,r.jsx)(n.li,{children:"Explore the publish-subscribe communication model using topics"}),"\n",(0,r.jsx)(n.li,{children:"Master service-based communication patterns"}),"\n"]})}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"ros-2-fundamentals-1-nodes-topics-and-services",children:"ROS 2 Fundamentals 1: Nodes, Topics, and Services"})}),"\n",(0,r.jsxs)(n.p,{children:["The Robot Operating System 2 (ROS 2) provides a flexible framework for developing robot applications. At its core, ROS 2 is designed around a ",(0,r.jsx)(n.strong,{children:"distributed"})," architecture that enables communication between different software components called ",(0,r.jsx)(n.em,{children:"nodes"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"understanding-ros-2-nodes",children:"Understanding ROS 2 Nodes"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"node"})," is a fundamental component of a ROS 2 system that performs computation. Nodes are typically organized to perform specific tasks, such as sensor processing, motion planning, or control. In ROS 2, nodes are implemented as processes that communicate with other nodes through various mechanisms."]}),"\n",(0,r.jsx)(n.h3,{id:"creating-your-first-node",children:"Creating Your First Node"}),"\n",(0,r.jsxs)(n.p,{children:["To create a node in ROS 2, you typically inherit from the ",(0,r.jsx)(n.code,{children:"rclcpp::Node"})," class (for C++) or use the ",(0,r.jsx)(n.code,{children:"rclpy"})," library (for Python). Each node must have a unique name within the ROS 2 domain to prevent conflicts."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Create a new ROS 2 package for our node\r\nros2 pkg create --build-type ament_python my_robot_node\n"})}),"\n",(0,r.jsx)(n.h2,{id:"communication-patterns-topics",children:"Communication Patterns: Topics"}),"\n",(0,r.jsxs)(n.p,{children:["ROS 2 uses a ",(0,r.jsx)(n.strong,{children:"publish-subscribe"})," model for asynchronous communication through ",(0,r.jsx)(n.em,{children:"topics"}),". Publishers send messages to a topic, and subscribers receive messages from that topic. This decouples the sender and receiver in both time and space."]}),"\n",(0,r.jsx)(n.admonition,{title:"Key Concept",type:"tip",children:(0,r.jsx)(n.p,{children:"Topics in ROS 2 use a publish-subscribe communication model where multiple publishers can send to the same topic and multiple subscribers can receive from the same topic, enabling flexible system architectures."})}),"\n",(0,r.jsx)(n.h3,{id:"working-with-topics",children:"Working with Topics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass MinimalPublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('minimal_publisher')\r\n        self.publisher = self.create_publisher(String, 'topic', 10)\r\n        timer_period = 0.5  # seconds\r\n        self.timer = self.create_timer(timer_period, self.timer_callback)\r\n        self.i = 0\r\n\r\n    def timer_callback(self):\r\n        msg = String()\r\n        msg.data = 'Hello World: %d' % self.i\r\n        self.publisher.publish(msg)\r\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\r\n        self.i += 1\n"})}),"\n",(0,r.jsx)(n.h2,{id:"communication-patterns-services",children:"Communication Patterns: Services"}),"\n",(0,r.jsxs)(n.p,{children:["Services provide a ",(0,r.jsx)(n.strong,{children:"request-response"})," communication model where a client sends a request to a server and waits for a response. This synchronous communication pattern is useful for operations that require a guaranteed response."]}),"\n",(0,r.jsx)(n.h3,{id:"implementing-services",children:"Implementing Services"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Create a service definition\r\n# example_srv/srv/AddTwoInts.srv\r\nint64 a\r\nint64 b\r\n---\r\nint64 sum\n"})}),"\n",(0,r.jsx)(n.p,{children:"Services are ideal for operations that have a clear input/output relationship and where the client needs to wait for completion."}),"\n",(0,r.jsx)(n.h2,{id:"hands-on-lab",children:"Hands-on Lab"}),"\n",(0,r.jsx)(n.p,{children:"Create a simple ROS 2 system with:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"A publisher node that publishes sensor data"}),"\n",(0,r.jsx)(n.li,{children:"A subscriber node that processes the data"}),"\n",(0,r.jsx)(n.li,{children:"A service server that performs calculations"}),"\n",(0,r.jsx)(n.li,{children:"A service client that requests those calculations"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"self-assessment",children:"Self-Assessment"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"What is the difference between topics and services in ROS 2?"}),"\n",(0,r.jsx)(n.li,{children:"Why is the publish-subscribe model beneficial for robotics applications?"}),"\n",(0,r.jsx)(n.li,{children:"How do nodes communicate in a ROS 2 system?"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);